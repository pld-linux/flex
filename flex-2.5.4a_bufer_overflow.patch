diff -urN flex-2.5.4.orig/initscan.c flex-2.5.4/initscan.c
--- flex-2.5.4.orig/initscan.c	Sat Sep  7 11:02:56 2002
+++ flex-2.5.4/initscan.c	Sat Sep  7 11:05:50 2002
@@ -11,6 +11,7 @@
 
 #include <stdio.h>
 #include <unistd.h>
+#include <errno.h>
 
 /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
 #ifdef c_plusplus
@@ -1291,7 +1292,15 @@
 	return CHAR;
 
 #define RETURNNAME \
+	if(strlen(yytext) < MAXLINE) \
+         { \
 	strcpy( nmstr, yytext ); \
+	 } \
+	else \
+	 { \
+	   fputs("Input line too long!\n", stderr); \
+	   exit(1);  \
+	 } /* end of else */  \
 	return NAME;
 
 #define PUT_BACK_STRING(str, start) \
@@ -1328,7 +1337,7 @@
 #define OPTION 17
 #define LINEDIR 18
 
-#line 1333 "scan.c"
+#line 1343 "scan.c"
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -1428,9 +1437,20 @@
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -1482,7 +1502,7 @@
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
 
-#line 94 "scan.l"
+#line 102 "scan.l"
 
 	static int bracelevel, didadef, indented_code;
 	static int doing_rule_action = false;
@@ -1493,7 +1513,7 @@
 	Char nmdef[MAXLINE], myesc();
 
 
-#line 1498 "scan.c"
+#line 1519 "scan.c"
 
 	if ( yy_init )
 		{
@@ -1580,32 +1600,32 @@
 
 case 1:
 YY_RULE_SETUP
-#line 105 "scan.l"
+#line 113 "scan.l"
 indented_code = true; BEGIN(CODEBLOCK);
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 106 "scan.l"
+#line 114 "scan.l"
 ACTION_ECHO; yy_push_state( COMMENT );
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 107 "scan.l"
+#line 115 "scan.l"
 yy_push_state( LINEDIR );
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 108 "scan.l"
+#line 116 "scan.l"
 return SCDECL;
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 109 "scan.l"
+#line 117 "scan.l"
 return XSCDECL;
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 110 "scan.l"
+#line 118 "scan.l"
 {
 			++linenum;
 			line_directive_out( (FILE *) 0, 1 );
@@ -1615,12 +1635,12 @@
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 117 "scan.l"
+#line 125 "scan.l"
 /* discard */
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 119 "scan.l"
+#line 127 "scan.l"
 {
 			sectnum = 2;
 			bracelevel = 0;
@@ -1632,95 +1652,103 @@
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 128 "scan.l"
+#line 136 "scan.l"
 yytext_is_array = false; ++linenum;
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 129 "scan.l"
+#line 137 "scan.l"
 yytext_is_array = true; ++linenum;
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 131 "scan.l"
+#line 139 "scan.l"
 BEGIN(OPTION); return OPTION_OP;
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 133 "scan.l"
+#line 141 "scan.l"
 ++linenum; /* ignore */
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 134 "scan.l"
+#line 142 "scan.l"
 ++linenum;	/* ignore */
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 136 "scan.l"
+#line 144 "scan.l"
 synerr( _( "unrecognized '%' directive" ) );
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 138 "scan.l"
+#line 146 "scan.l"
+{
+			if(strlen(yytext) < MAXLINE) 
 {
 			strcpy( nmstr, yytext );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } /* end of else */  
 			didadef = false;
 			BEGIN(PICKUPDEF);
 			}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 144 "scan.l"
+#line 160 "scan.l"
 RETURNNAME;
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 145 "scan.l"
+#line 161 "scan.l"
 ++linenum; /* allows blank lines in section 1 */
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 146 "scan.l"
+#line 162 "scan.l"
 ACTION_ECHO; ++linenum; /* maybe end of comment line */
 	YY_BREAK
 
 
 case 19:
 YY_RULE_SETUP
-#line 151 "scan.l"
+#line 167 "scan.l"
 ACTION_ECHO; yy_pop_state();
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 152 "scan.l"
+#line 168 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 153 "scan.l"
+#line 169 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 154 "scan.l"
+#line 170 "scan.l"
 ++linenum; ACTION_ECHO;
 	YY_BREAK
 
 
 case 23:
 YY_RULE_SETUP
-#line 158 "scan.l"
+#line 174 "scan.l"
 yy_pop_state();
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 159 "scan.l"
+#line 175 "scan.l"
 linenum = myctoi( yytext );
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 161 "scan.l"
+#line 177 "scan.l"
 {
 			flex_free( (void *) infilename );
 			infilename = copy_string( yytext + 1 );
@@ -1729,24 +1757,24 @@
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 166 "scan.l"
+#line 182 "scan.l"
 /* ignore spurious characters */
 	YY_BREAK
 
 
 case 27:
 YY_RULE_SETUP
-#line 170 "scan.l"
+#line 186 "scan.l"
 ++linenum; BEGIN(INITIAL);
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 172 "scan.l"
+#line 188 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 174 "scan.l"
+#line 190 "scan.l"
 {
 			++linenum;
 			ACTION_ECHO;
@@ -1758,14 +1786,24 @@
 
 case 30:
 YY_RULE_SETUP
-#line 184 "scan.l"
+#line 200 "scan.l"
 /* separates name and definition */
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 186 "scan.l"
+#line 202 "scan.l"
+{
+		        if(strlen(yytext) < MAXLINE)
 {
 			strcpy( (char *) nmdef, yytext );
+		         } 
+		        else
+		         {
+		           fputs("Input line too long!\n", stderr);
+		           exit(1); 
+		         } /* end of else */
+  
+ 
 
 			/* Skip trailing whitespace. */
 			for ( i = strlen( (char *) nmdef ) - 1;
@@ -1781,7 +1819,7 @@
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 201 "scan.l"
+#line 227 "scan.l"
 {
 			if ( ! didadef )
 				synerr( _( "incomplete name definition" ) );
@@ -1793,94 +1831,94 @@
 
 case 33:
 YY_RULE_SETUP
-#line 211 "scan.l"
+#line 237 "scan.l"
 ++linenum; BEGIN(INITIAL);
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 212 "scan.l"
+#line 238 "scan.l"
 option_sense = true;
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 214 "scan.l"
+#line 240 "scan.l"
 return '=';
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 216 "scan.l"
+#line 242 "scan.l"
 option_sense = ! option_sense;
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 218 "scan.l"
+#line 244 "scan.l"
 csize = option_sense ? 128 : 256;
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 219 "scan.l"
+#line 245 "scan.l"
 csize = option_sense ? 256 : 128;
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 221 "scan.l"
+#line 247 "scan.l"
 long_align = option_sense;
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 222 "scan.l"
+#line 248 "scan.l"
 {
 			action_define( "YY_ALWAYS_INTERACTIVE", option_sense );
 			}
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 225 "scan.l"
+#line 251 "scan.l"
 yytext_is_array = option_sense;
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 226 "scan.l"
+#line 252 "scan.l"
 backing_up_report = option_sense;
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 227 "scan.l"
+#line 253 "scan.l"
 interactive = ! option_sense;
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 228 "scan.l"
+#line 254 "scan.l"
 C_plus_plus = option_sense;
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 229 "scan.l"
+#line 255 "scan.l"
 caseins = ! option_sense;
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 230 "scan.l"
+#line 256 "scan.l"
 caseins = option_sense;
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 231 "scan.l"
+#line 257 "scan.l"
 ddebug = option_sense;
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 232 "scan.l"
+#line 258 "scan.l"
 spprdflt = ! option_sense;
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 233 "scan.l"
+#line 259 "scan.l"
 useecs = option_sense;
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 234 "scan.l"
+#line 260 "scan.l"
 {
 			useecs = usemecs = false;
 			use_read = fullspd = true;
@@ -1888,7 +1926,7 @@
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 238 "scan.l"
+#line 264 "scan.l"
 {
 			useecs = usemecs = false;
 			use_read = fulltbl = true;
@@ -1896,22 +1934,22 @@
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 242 "scan.l"
+#line 268 "scan.l"
 ACTION_IFDEF("YY_NO_INPUT", ! option_sense);
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 243 "scan.l"
+#line 269 "scan.l"
 interactive = option_sense;
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 244 "scan.l"
+#line 270 "scan.l"
 lex_compat = option_sense;
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 245 "scan.l"
+#line 271 "scan.l"
 {
 			action_define( "YY_MAIN", option_sense );
 			do_yywrap = ! option_sense;
@@ -1919,138 +1957,146 @@
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 249 "scan.l"
+#line 275 "scan.l"
 usemecs = option_sense;
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 250 "scan.l"
+#line 276 "scan.l"
 {
 			action_define( "YY_NEVER_INTERACTIVE", option_sense );
 			}
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 253 "scan.l"
+#line 279 "scan.l"
 performance_report += option_sense ? 1 : -1;
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 254 "scan.l"
+#line 280 "scan.l"
 yytext_is_array = ! option_sense;
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 255 "scan.l"
+#line 281 "scan.l"
 use_read = option_sense;
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 256 "scan.l"
+#line 282 "scan.l"
 reject_really_used = option_sense;
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 257 "scan.l"
+#line 283 "scan.l"
 action_define( "YY_STACK_USED", option_sense );
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 258 "scan.l"
+#line 284 "scan.l"
 do_stdinit = option_sense;
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 259 "scan.l"
+#line 285 "scan.l"
 use_stdout = option_sense;
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 260 "scan.l"
+#line 286 "scan.l"
 ACTION_IFDEF("YY_NO_UNPUT", ! option_sense);
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 261 "scan.l"
+#line 287 "scan.l"
 printstats = option_sense;
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 262 "scan.l"
+#line 288 "scan.l"
 nowarn = ! option_sense;
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 263 "scan.l"
+#line 289 "scan.l"
 do_yylineno = option_sense;
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 264 "scan.l"
+#line 290 "scan.l"
 yymore_really_used = option_sense;
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 265 "scan.l"
+#line 291 "scan.l"
 do_yywrap = option_sense;
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 267 "scan.l"
+#line 293 "scan.l"
 ACTION_IFDEF("YY_NO_PUSH_STATE", ! option_sense);
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 268 "scan.l"
+#line 294 "scan.l"
 ACTION_IFDEF("YY_NO_POP_STATE", ! option_sense);
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 269 "scan.l"
+#line 295 "scan.l"
 ACTION_IFDEF("YY_NO_TOP_STATE", ! option_sense);
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 271 "scan.l"
+#line 297 "scan.l"
 ACTION_IFDEF("YY_NO_SCAN_BUFFER", ! option_sense);
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 272 "scan.l"
+#line 298 "scan.l"
 ACTION_IFDEF("YY_NO_SCAN_BYTES", ! option_sense);
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 273 "scan.l"
+#line 299 "scan.l"
 ACTION_IFDEF("YY_NO_SCAN_STRING", ! option_sense);
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 275 "scan.l"
+#line 301 "scan.l"
 return OPT_OUTFILE;
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 276 "scan.l"
+#line 302 "scan.l"
 return OPT_PREFIX;
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 277 "scan.l"
+#line 303 "scan.l"
 return OPT_YYCLASS;
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 279 "scan.l"
+#line 305 "scan.l"
+{
+			if(strlen(yytext + 1 ) < MAXLINE) 
 {
 			strcpy( nmstr, yytext + 1 );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } /* end of else */			
 			nmstr[strlen( nmstr ) - 1] = '\0';
 			return NAME;
 			}
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 285 "scan.l"
+#line 319 "scan.l"
 {
 			format_synerr( _( "unrecognized %%option: %s" ),
 				yytext );
@@ -2060,28 +2106,28 @@
 
 case 82:
 YY_RULE_SETUP
-#line 292 "scan.l"
+#line 326 "scan.l"
 ++linenum; BEGIN(INITIAL);
 	YY_BREAK
 
 case 83:
 YY_RULE_SETUP
-#line 296 "scan.l"
+#line 330 "scan.l"
 ++bracelevel; yyless( 2 );	/* eat only %{ */
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 297 "scan.l"
+#line 331 "scan.l"
 --bracelevel; yyless( 2 );	/* eat only %} */
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 299 "scan.l"
+#line 333 "scan.l"
 ACTION_ECHO;	/* indented code in prolog */
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 301 "scan.l"
+#line 335 "scan.l"
 {	/* non-indented code */
 			if ( bracelevel <= 0 )
 				{ /* not in %{ ... %} */
@@ -2096,16 +2142,16 @@
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 313 "scan.l"
+#line 347 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 314 "scan.l"
+#line 348 "scan.l"
 ++linenum; ACTION_ECHO;
 	YY_BREAK
 case YY_STATE_EOF(SECT2PROLOG):
-#line 316 "scan.l"
+#line 350 "scan.l"
 {
 			mark_prolog();
 			sectnum = 0;
@@ -2116,12 +2162,12 @@
 
 case 89:
 YY_RULE_SETUP
-#line 324 "scan.l"
+#line 358 "scan.l"
 ++linenum; /* allow blank lines in section 2 */
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 326 "scan.l"
+#line 360 "scan.l"
 {
 			indented_code = false;
 			doing_codeblock = true;
@@ -2131,17 +2177,17 @@
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 333 "scan.l"
+#line 367 "scan.l"
 BEGIN(SC); return '<';
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 334 "scan.l"
+#line 368 "scan.l"
 return '^';
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 335 "scan.l"
+#line 369 "scan.l"
 BEGIN(QUOTE); return '"';
 	YY_BREAK
 case 94:
@@ -2149,7 +2195,7 @@
 yy_c_buf_p = yy_cp = yy_bp + 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 336 "scan.l"
+#line 370 "scan.l"
 BEGIN(NUM); return '{';
 	YY_BREAK
 case 95:
@@ -2157,12 +2203,12 @@
 yy_c_buf_p = yy_cp = yy_bp + 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 337 "scan.l"
+#line 371 "scan.l"
 return '$';
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 339 "scan.l"
+#line 373 "scan.l"
 {
 			bracelevel = 1;
 			BEGIN(PERCENT_BRACE_ACTION);
@@ -2177,12 +2223,12 @@
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 350 "scan.l"
+#line 384 "scan.l"
 continued_action = true; ++linenum; return '\n';
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 352 "scan.l"
+#line 386 "scan.l"
 {
 			yyless( yyleng - 2 );	/* put back '/', '*' */
 			bracelevel = 0;
@@ -2192,12 +2238,12 @@
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 359 "scan.l"
+#line 393 "scan.l"
 /* allow indented rules */
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 361 "scan.l"
+#line 395 "scan.l"
 {
 			/* This rule is separate from the one below because
 			 * otherwise we get variable trailing context, so
@@ -2217,7 +2263,7 @@
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 378 "scan.l"
+#line 412 "scan.l"
 {
 			bracelevel = 0;
 			continued_action = false;
@@ -2233,15 +2279,15 @@
 			}
 	YY_BREAK
 case 102:
-#line 393 "scan.l"
+#line 427 "scan.l"
 case 103:
 YY_RULE_SETUP
-#line 393 "scan.l"
+#line 427 "scan.l"
 return EOF_OP;
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 395 "scan.l"
+#line 429 "scan.l"
 {
 			sectnum = 3;
 			BEGIN(SECT3);
@@ -2250,11 +2296,19 @@
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 401 "scan.l"
+#line 435 "scan.l"
 {
 			int cclval;
 
+			if(strlen(yytext ) < MAXLINE) 
+        		 { 
 			strcpy( nmstr, yytext );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } 
 
 			/* Check to see if we've already encountered this
 			 * ccl.
@@ -2287,12 +2341,20 @@
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 435 "scan.l"
+#line 477 "scan.l"
 {
 			register Char *nmdefptr;
 			Char *ndlookup();
 
+			if(strlen(yytext + 1 ) < MAXLINE) 
+        		 { 
 			strcpy( nmstr, yytext + 1 );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } /* end of else */			
 			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
 
 			if ( (nmdefptr = ndlookup( nmstr )) == 0 )
@@ -2324,24 +2386,24 @@
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 469 "scan.l"
+#line 519 "scan.l"
 return (unsigned char) yytext[0];
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 470 "scan.l"
+#line 520 "scan.l"
 RETURNCHAR;
 	YY_BREAK
 
 
 case 109:
 YY_RULE_SETUP
-#line 475 "scan.l"
+#line 525 "scan.l"
 return (unsigned char) yytext[0];
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 476 "scan.l"
+#line 526 "scan.l"
 BEGIN(SECT2); return '>';
 	YY_BREAK
 case 111:
@@ -2349,17 +2411,17 @@
 yy_c_buf_p = yy_cp = yy_bp + 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 477 "scan.l"
+#line 527 "scan.l"
 BEGIN(CARETISBOL); return '>';
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 478 "scan.l"
+#line 528 "scan.l"
 RETURNNAME;
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 479 "scan.l"
+#line 529 "scan.l"
 {
 			format_synerr( _( "bad <start condition>: %s" ),
 				yytext );
@@ -2368,23 +2430,23 @@
 
 case 114:
 YY_RULE_SETUP
-#line 485 "scan.l"
+#line 535 "scan.l"
 BEGIN(SECT2); return '^';
 	YY_BREAK
 
 case 115:
 YY_RULE_SETUP
-#line 489 "scan.l"
+#line 539 "scan.l"
 RETURNCHAR;
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 490 "scan.l"
+#line 540 "scan.l"
 BEGIN(SECT2); return '"';
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 492 "scan.l"
+#line 542 "scan.l"
 {
 			synerr( _( "missing quote" ) );
 			BEGIN(SECT2);
@@ -2399,7 +2461,7 @@
 yy_c_buf_p = yy_cp = yy_bp + 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 502 "scan.l"
+#line 552 "scan.l"
 BEGIN(CCL); return '^';
 	YY_BREAK
 case 119:
@@ -2407,12 +2469,12 @@
 yy_c_buf_p = yy_cp = yy_bp + 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 503 "scan.l"
+#line 553 "scan.l"
 return '^';
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 504 "scan.l"
+#line 554 "scan.l"
 BEGIN(CCL); RETURNCHAR;
 	YY_BREAK
 
@@ -2422,22 +2484,22 @@
 yy_c_buf_p = yy_cp = yy_bp + 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 508 "scan.l"
+#line 558 "scan.l"
 return '-';
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 509 "scan.l"
+#line 559 "scan.l"
 RETURNCHAR;
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 510 "scan.l"
+#line 560 "scan.l"
 BEGIN(SECT2); return ']';
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-#line 511 "scan.l"
+#line 561 "scan.l"
 {
 			synerr( _( "bad character class" ) );
 			BEGIN(SECT2);
@@ -2448,67 +2510,67 @@
 
 case 125:
 YY_RULE_SETUP
-#line 519 "scan.l"
+#line 569 "scan.l"
 BEGIN(CCL); return CCE_ALNUM;
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 520 "scan.l"
+#line 570 "scan.l"
 BEGIN(CCL); return CCE_ALPHA;
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-#line 521 "scan.l"
+#line 571 "scan.l"
 BEGIN(CCL); return CCE_BLANK;
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-#line 522 "scan.l"
+#line 572 "scan.l"
 BEGIN(CCL); return CCE_CNTRL;
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 523 "scan.l"
+#line 573 "scan.l"
 BEGIN(CCL); return CCE_DIGIT;
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-#line 524 "scan.l"
+#line 574 "scan.l"
 BEGIN(CCL); return CCE_GRAPH;
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-#line 525 "scan.l"
+#line 575 "scan.l"
 BEGIN(CCL); return CCE_LOWER;
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 526 "scan.l"
+#line 576 "scan.l"
 BEGIN(CCL); return CCE_PRINT;
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 527 "scan.l"
+#line 577 "scan.l"
 BEGIN(CCL); return CCE_PUNCT;
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 528 "scan.l"
+#line 578 "scan.l"
 BEGIN(CCL); return CCE_SPACE;
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 529 "scan.l"
+#line 579 "scan.l"
 BEGIN(CCL); return CCE_UPPER;
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 530 "scan.l"
+#line 580 "scan.l"
 BEGIN(CCL); return CCE_XDIGIT;
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 531 "scan.l"
+#line 581 "scan.l"
 {
 			format_synerr(
 				_( "bad character class expression: %s" ),
@@ -2520,7 +2582,7 @@
 
 case 138:
 YY_RULE_SETUP
-#line 540 "scan.l"
+#line 590 "scan.l"
 {
 			yylval = myctoi( yytext );
 			return NUMBER;
@@ -2528,17 +2590,17 @@
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 545 "scan.l"
+#line 595 "scan.l"
 return ',';
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 546 "scan.l"
+#line 596 "scan.l"
 BEGIN(SECT2); return '}';
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 548 "scan.l"
+#line 598 "scan.l"
 {
 			synerr( _( "bad character inside {}'s" ) );
 			BEGIN(SECT2);
@@ -2547,7 +2609,7 @@
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 554 "scan.l"
+#line 604 "scan.l"
 {
 			synerr( _( "missing }" ) );
 			BEGIN(SECT2);
@@ -2559,18 +2621,18 @@
 
 case 143:
 YY_RULE_SETUP
-#line 564 "scan.l"
+#line 614 "scan.l"
 bracelevel = 0;
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 566 "scan.l"
+#line 616 "scan.l"
 ACTION_ECHO; yy_push_state( COMMENT );
 	YY_BREAK
 
 case 145:
 YY_RULE_SETUP
-#line 569 "scan.l"
+#line 619 "scan.l"
 {
 			ACTION_ECHO;
 			CHECK_REJECT(yytext);
@@ -2578,7 +2640,7 @@
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
-#line 573 "scan.l"
+#line 623 "scan.l"
 {
 			ACTION_ECHO;
 			CHECK_YYMORE(yytext);
@@ -2587,12 +2649,12 @@
 
 case 147:
 YY_RULE_SETUP
-#line 579 "scan.l"
+#line 629 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
-#line 580 "scan.l"
+#line 630 "scan.l"
 {
 			++linenum;
 			ACTION_ECHO;
@@ -2612,37 +2674,37 @@
 
 case 149:
 YY_RULE_SETUP
-#line 598 "scan.l"
+#line 648 "scan.l"
 ACTION_ECHO; ++bracelevel;
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
-#line 599 "scan.l"
+#line 649 "scan.l"
 ACTION_ECHO; --bracelevel;
 	YY_BREAK
 case 151:
 YY_RULE_SETUP
-#line 600 "scan.l"
+#line 650 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
-#line 601 "scan.l"
+#line 651 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 602 "scan.l"
+#line 652 "scan.l"
 ACTION_ECHO; /* character constant */
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
-#line 603 "scan.l"
+#line 653 "scan.l"
 ACTION_ECHO; BEGIN(ACTION_STRING);
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
-#line 604 "scan.l"
+#line 654 "scan.l"
 {
 			++linenum;
 			ACTION_ECHO;
@@ -2658,41 +2720,41 @@
 	YY_BREAK
 case 156:
 YY_RULE_SETUP
-#line 616 "scan.l"
+#line 666 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 
 
 case 157:
 YY_RULE_SETUP
-#line 620 "scan.l"
+#line 670 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
-#line 621 "scan.l"
+#line 671 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
-#line 622 "scan.l"
+#line 672 "scan.l"
 ++linenum; ACTION_ECHO;
 	YY_BREAK
 case 160:
 YY_RULE_SETUP
-#line 623 "scan.l"
+#line 673 "scan.l"
 ACTION_ECHO; BEGIN(ACTION);
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 624 "scan.l"
+#line 674 "scan.l"
 ACTION_ECHO;
 	YY_BREAK
 
 case YY_STATE_EOF(COMMENT):
 case YY_STATE_EOF(ACTION):
 case YY_STATE_EOF(ACTION_STRING):
-#line 627 "scan.l"
+#line 677 "scan.l"
 {
 			synerr( _( "EOF encountered inside an action" ) );
 			yyterminate();
@@ -2700,7 +2762,7 @@
 	YY_BREAK
 case 162:
 YY_RULE_SETUP
-#line 633 "scan.l"
+#line 683 "scan.l"
 {
 			yylval = myesc( (Char *) yytext );
 
@@ -2713,25 +2775,25 @@
 
 case 163:
 YY_RULE_SETUP
-#line 644 "scan.l"
+#line 694 "scan.l"
 ECHO;
 	YY_BREAK
 case YY_STATE_EOF(SECT3):
-#line 645 "scan.l"
+#line 695 "scan.l"
 sectnum = 0; yyterminate();
 	YY_BREAK
 
 case 164:
 YY_RULE_SETUP
-#line 648 "scan.l"
+#line 698 "scan.l"
 format_synerr( _( "bad character: %s" ), yytext );
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 650 "scan.l"
+#line 700 "scan.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
 	YY_BREAK
-#line 2736 "scan.c"
+#line 2799 "scan.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(SECT2):
 case YY_STATE_EOF(CODEBLOCK):
@@ -3626,7 +3688,7 @@
 	return 0;
 	}
 #endif
-#line 650 "scan.l"
+#line 700 "scan.l"
 
 
 
diff -urN flex-2.5.4.orig/scan.l flex-2.5.4/scan.l
--- flex-2.5.4.orig/scan.l	Sun Jul 27 04:44:13 1997
+++ flex-2.5.4/scan.l	Sat Sep  7 11:04:34 2002
@@ -49,7 +49,15 @@
 	return CHAR;
 
 #define RETURNNAME \
+	if(strlen(yytext) < MAXLINE) \
+         { \
 	strcpy( nmstr, yytext ); \
+	 } \
+	else \
+	 { \
+	   fputs("Input line too long!\n", stderr); \
+	   exit(1);  \
+	 } /* end of else */  \
 	return NAME;
 
 #define PUT_BACK_STRING(str, start) \
@@ -136,7 +144,15 @@
 	^"%"[^sxaceknopr{}].*	synerr( _( "unrecognized '%' directive" ) );
 
 	^{NAME}		{
+			if(strlen(yytext) < MAXLINE) 
+        		 { 
 			strcpy( nmstr, yytext );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } /* end of else */  
 			didadef = false;
 			BEGIN(PICKUPDEF);
 			}
@@ -184,7 +200,17 @@
 	{WS}		/* separates name and definition */
 
 	{NOT_WS}.*	{
+		        if(strlen(yytext) < MAXLINE)
+		         {
 			strcpy( (char *) nmdef, yytext );
+		         } 
+		        else
+		         {
+		           fputs("Input line too long!\n", stderr);
+		           exit(1); 
+		         } /* end of else */
+  
+ 
 
 			/* Skip trailing whitespace. */
 			for ( i = strlen( (char *) nmdef ) - 1;
@@ -277,7 +303,15 @@
 	yyclass		return OPT_YYCLASS;
 
 	\"[^"\n]*\"	{
+			if(strlen(yytext + 1 ) < MAXLINE) 
+        		 { 
 			strcpy( nmstr, yytext + 1 );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } /* end of else */			
 			nmstr[strlen( nmstr ) - 1] = '\0';
 			return NAME;
 			}
@@ -401,7 +435,15 @@
 	"["({FIRST_CCL_CHAR}|{CCL_EXPR})({CCL_CHAR}|{CCL_EXPR})*	{
 			int cclval;
 
+			if(strlen(yytext ) < MAXLINE) 
+        		 { 
 			strcpy( nmstr, yytext );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } 
 
 			/* Check to see if we've already encountered this
 			 * ccl.
@@ -436,7 +478,15 @@
 			register Char *nmdefptr;
 			Char *ndlookup();
 
+			if(strlen(yytext + 1 ) < MAXLINE) 
+        		 { 
 			strcpy( nmstr, yytext + 1 );
+			 } 
+			else 
+			 { 
+			   fputs("Input line too long!\n", stderr); 
+			   exit(1);  
+			 } /* end of else */			
 			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
 
 			if ( (nmdefptr = ndlookup( nmstr )) == 0 )
